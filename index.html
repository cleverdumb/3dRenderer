<html>
    <head>
        <title>AABB 3D</title>
    </head>
    <body>
        <canvas id='cvs'></canvas>
        <br>
        <input type='range' min='-400' max='400' id='xSlide' step='2'><span id='xVal'>X: 0</span><br>
        <input type='range' min='0' max='100' id='ySlide'><span id='yVal'>Y: 0</span><br>
        <input type='range' min='-400' max='400' id='zSlide' step='2'><span id='zVal'>Z: 0</span><br>
        FOV<input type='range' min='100' max='150' id='fovSlide'>
        <script>
            const cvs = document.getElementById('cvs');
            const ctx = cvs.getContext('2d');

            const cw = 700;
            const ch = 700;

            cvs.width = cw;
            cvs.height = ch;
            cvs.style.border = '1px solid black';

            let scrY = 20;
            let fov = 125;

            let scrX = 200;
            let scrZ = 200;

            let c = ['red', 'green', 'blue', 'black', 'brown', 'purple', 'yellow', 'orange', 'cyan', 'pink']

            let dx = 0, dy = 50, dz = 0;

            document.getElementById('xSlide').oninput = ()=>{
                dx = parseInt(document.getElementById('xSlide').value);
                document.getElementById('xVal').innerHTML = `X: ${dx}`;
                tri = cuboidToTri([
                    [-50 + dx, 50 + dy, 50 + dz],
                    [50 + dx, 50 + dy, 50 + dz],
                    [50 + dx, 50 + dy, -50 + dz],
                    [-50 + dx, 50 + dy, -50 + dz],
                    [-50 + dx, 150 + dy, 50 + dz],
                    [50 + dx, 150 + dy, 50 + dz],
                    [50 + dx, 150 + dy, -50 + dz],
                    [-50 + dx, 150 + dy, -50 + dz]
                ])
                render();
            }

            document.getElementById('ySlide').oninput = ()=>{
                dy = parseInt(document.getElementById('ySlide').value);
                document.getElementById('yVal').innerHTML = `Y: ${dy}`;
                tri = cuboidToTri([
                    [-50 + dx, 50 + dy, 50 + dz],
                    [50 + dx, 50 + dy, 50 + dz],
                    [50 + dx, 50 + dy, -50 + dz],
                    [-50 + dx, 50 + dy, -50 + dz],
                    [-50 + dx, 150 + dy, 50 + dz],
                    [50 + dx, 150 + dy, 50 + dz],
                    [50 + dx, 150 + dy, -50 + dz],
                    [-50 + dx, 150 + dy, -50 + dz]
                ])
                render();
            }
            
            document.getElementById('zSlide').oninput = ()=>{
                dz = parseInt(document.getElementById('zSlide').value);
                document.getElementById('zVal').innerHTML = `Z: ${dz}`;
                tri = cuboidToTri([
                    [-50 + dx, 50 + dy, 50 + dz],
                    [50 + dx, 50 + dy, 50 + dz],
                    [50 + dx, 50 + dy, -50 + dz],
                    [-50 + dx, 50 + dy, -50 + dz],
                    [-50 + dx, 150 + dy, 50 + dz],
                    [50 + dx, 150 + dy, 50 + dz],
                    [50 + dx, 150 + dy, -50 + dz],
                    [-50 + dx, 150 + dy, -50 + dz]
                ])
                render();
            }

            document.getElementById('fovSlide').oninput = ()=>{
                fov = parseInt(document.getElementById('fovSlide').value);
                render();
            }

            // p0, p1, p2, p3 one face, clockwise, p4 - p1, p5 - p2, p6 - p3, p7 - p4
            // triangles: p0 -> p1 -> p2 -> p0
            // crossProduct: (p0 -> p1) x (p1 -> p2)

            /*
                4 --------- 5
              / |         / |
            0 --------- 1   |
            |   |       |   |
            |   7 ------|-- 6
            | /         | /
            3 --------- 2
            */

            function cuboidToTri(p) {
                return [
                    // front 0123
                    [p[1], p[0], p[3]],
                    [p[3], p[2], p[1]],

                    // left 0374
                    [p[0], p[4], p[7]],
                    [p[7], p[3], p[0]],

                    // right 1562
                    [p[5], p[1], p[2]],
                    [p[2], p[6], p[5]],

                    // back 4567
                    [p[4], p[5], p[6]],
                    [p[6], p[7], p[4]],

                    // top 4510
                    [p[5], p[4], p[0]],
                    [p[0], p[1], p[5]],

                    // bottom 7623
                    [p[2], p[3], p[7]],
                    [p[7], p[6], p[2]]
                ]
            }

            function aabb(tX, tY, tZ, tXp, tYp, tZp) {
                return cuboidToTri([
                    [tX + dx,       tY + dy,       tZ + tZp + dz],
                    [tX + tXp + dx, tY + dy,       tZ + tZp + dz],
                    [tX + tXp + dx, tY + dy,       tZ + dz],
                    [tX + dx,       tY + dy,       tZ + dz],
                    [tX + dx,       tY + tYp + dy, tZ + tZp + dz],
                    [tX + tXp + dx, tY + tYp + dy, tZ + tZp + dz],
                    [tX + tXp + dx, tY + tYp + dy, tZ + dz],
                    [tX + dx,       tY + tYp + dy, tZ + dz]
                ])
            }
            // let tX = -50, tY = 50, tZ = -50, tXp = 100, tYp = 100, tZp = 100;
            let tri = aabb(-50, 50, -50, 100, 100, 100);

            function crossProduct(v1, v2) {
                return [v1[1]*v2[2] - v1[2]*v2[1], v1[2]*v2[0]-v1[0]*v2[2], v1[0]*v2[1] - v1[1]*v2[0]];
            }

            function dotProduct(v1, v2) {
                return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
            }

            function normalise(v) {
                let mag = Math.hypot(v[0], v[1], v[2]);
                return [v[0]/mag, v[1]/mag, v[2]/mag];
            }

            function multMatrix(m, v) {
                return [
                    dotProduct([m[0][0], m[0][1], m[0][2]], v),
                    dotProduct([m[1][0], m[1][1], m[1][2]], v),
                    dotProduct([m[2][0], m[2][1], m[2][2]], v)
                ]
            }

            function rotatePoint(p, x, y, z) {
                if (x !== 0) {
                    return multMatrix([
                        [1, 0,           0],
                        [0, Math.cos(x), -Math.sin(x)],
                        [0, Math.sin(x), Math.cos(x)]
                    ], p)
                }
                else if (y !== 0) {
                    return multMatrix([
                        [Math.cos(y),  0, Math.sin(y)],
                        [0,            1, 0],
                        [-Math.sin(y), 0, Math.cos(y)]
                    ], p)
                }
                else if (z !== 0) {
                    return multMatrix([
                        [Math.cos(z), -Math.sin(z), 0],
                        [Math.sin(z), Math.cos(z),  0],
                        [0,           0,            1]
                    ], p)
                }
            }

            function rotate(x, y, z) {
                let ax = x / 180 * Math.PI;
                let ay = y / 180 * Math.PI;
                let az = z / 180 * Math.PI;
                tri = tri.map(t=>{
                    return t.map(p=>{
                        return rotatePoint(p, ax, ay, az);
                    })
                })
            }

            let depths = tri.map(t=>{
                let sum = 0;
                t.forEach(p => {
                    sum += Math.hypot(p[0], p[1], p[2]);
                })
                return [...t, sum/3];
            })

            depths.sort((a, b)=>{
                return b[3]-a[3];
            })

            // console.log(depths);

            function render() {
                depths = tri.map(t=>{
                    let sum = 0;
                    t.forEach(p => {
                        sum += Math.hypot(p[0], p[1], p[2]);
                    })
                    return [...t, sum/3];
                })

                depths.sort((a, b)=>{
                    return b[3]-a[3];
                })
                let toRender = [];
                depths.forEach(t=>{
                    let a = [t[1][0]-t[0][0], t[1][1]-t[0][1], t[1][2]-t[0][2]];
                    let b = [t[2][0]-t[1][0], t[2][1]-t[1][1], t[2][2]-t[1][2]];

                    let cross = crossProduct(a, b);
                    // let crossMag = Math.hypot(cross[0], cross[1], cross[2]);
                    // console.log(crossMag);
                    // cross[0] = cross[0] / crossMag;
                    // cross[1] = cross[1] / crossMag;
                    // cross[2] = cross[2] / crossMag;
                    cross = normalise(cross);
                    // console.log(cross);

                    let ref = [-t[0][0], -t[0][1], -t[0][2]];
                    ref = normalise(ref);
                    
                    // console.log(ref);

                    // console.log(dotProduct(ref, cross));
                    if (dotProduct(ref, cross) > 0) {
                        toRender.push(t);
                    }
                })
                ctx.clearRect(0, 0, cw, ch);
                // console.log(toRender);
                toRender.forEach((t, ti)=>{
                    let proj = [];
                    t.forEach((p, i)=>{
                        if (i < 3) {
                            // console.log(p);
                            console.log('-----------------------------------');
                            console.log(p[0] * scrY / p[1]);
                            console.log((scrX/2 + p[0] * scrY / p[1]) / scrX * cw);
                            proj.push([(scrX/2 + p[0] * scrY / p[1]) / scrX * cw, ch - (scrZ/2 + p[2] * scrY / p[1]) / scrZ * ch])
                            // proj.push([
                            //     (p[0]/p[1]/Math.tan(fov/180*Math.PI/2)+1) * cw/2,
                            //     (1 - p[2]/p[1]/Math.tan(fov/180*Math.PI/2)) * ch/2
                            // ])
                        }
                    })
                    console.log(c[ti]);
                    console.log('^^^^^^^^^^^^^^^^^^^^^^^^')
                    // console.log(proj);
                    ctx.beginPath();
                    // ctx.fillStyle = c[Math.floor((ti)/2)]
                    ctx.fillStyle = c[ti];
                    // console.log(c[Math.floor((ti)/2)])
                    ctx.strokeStyle = 'black';
                    ctx.moveTo(proj[0][0], proj[0][1]);
                    ctx.lineTo(proj[1][0], proj[1][1]);
                    ctx.lineTo(proj[2][0], proj[2][1]);
                    ctx.lineTo(proj[0][0], proj[0][1]);
                    ctx.fill();
                    ctx.stroke();
                    ctx.closePath();
                })
            }

            render();

            let rotated = 0;

            rotate(0, 0, -60);
            render();

            document.body.addEventListener('keydown', e=>{
                
                if (e.key == 'a') {
                    rotate(0, 0, 5);
                    rotated += 5;
                }
                else if (e.key == 'd') {
                    rotate(0, 0, -5);
                    rotated -= 5;
                }

                console.log(rotated);

                render();
            })
        </script>
    </body>
</html>